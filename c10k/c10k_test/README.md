# C10K 性能测试项目

这个项目旨在使用不同的实现方式来测试和比较 C10K（10,000 并发连接）性能。

## 实现方式

目前包含的实现：

1. [Flask + Gunicorn](./flask_gunicorn/README.md)

计划添加的实现：

- 基于 asyncio 的实现
- 基于 gevent 的实现
- 其他高性能 Python Web 框架（如 FastAPI）的实现

## 目的

这个项目的主要目的是：

1. 测试不同实现方式下的 C10K 性能
2. 比较分析各种实现方式的优缺点和底层原理
3. 了解如何优化 Python Web 服务器以处理高并发请求

## 如何使用

每种实现方式都有其own的 README 文件，详细说明了如何设置和运行测试。请参阅各个子目录中的说明。

## 业界主流网关性能参考

以下数据基于理想测试环境（本地网络、小响应体<1KB、简单路由规则、无复杂中间件）。

### 单核性能 (QPS/IOPS)

| 网关     | 单核IOPS     | 特点                    |
|---------|-------------|------------------------|
| Nginx   | 10-20k QPS  | 静态文件处理性能最优        |
| HAProxy | 15-25k QPS  | 负载均衡场景性能优异        |
| Envoy   | 15-30k QPS  | 现代架构，服务网格场景优秀    |
| Traefik | 8-15k QPS   | 容器化支持好，配置更灵活     |

### 延迟性能

| 网关     | P50延迟      | P99延迟     | P999延迟    |
|---------|-------------|------------|------------|
| Nginx   | 0.2-0.5ms   | 1-2ms      | 3-5ms      |
| HAProxy | 0.3-0.6ms   | 1-2ms      | 3-6ms      |
| Envoy   | 0.4-0.8ms   | 1.5-3ms    | 4-8ms      |
| Traefik | 0.5-1ms     | 2-4ms      | 5-10ms     |

### 影响性能的主要因素

1. **硬件因素**
   - CPU频率和缓存
   - 内存速度
   - 网卡性能
   - NUMA架构影响

2. **软件配置**
   - 内核参数调优
   - TCP配置（如tcp_nodelay）
   - 进程/线程模型
   - 事件模型选择（epoll等）

3. **运行时条件**
   - 并发连接数
   - 请求体大小
   - SSL/TLS开销
   - 网络拥塞情况

4. **业务场景**
   - 路由规则复杂度
   - 中间件处理逻辑
   - 后端服务响应时间
   - 监控和追踪开销

### 性能优化建议

1. 使用 TCP keepalive
2. 启用 HTTP/2
3. 合理配置 buffer size
4. 优化系统参数
5. 使用高性能硬件
6. 简化路由规则
7. 减少中间件层级

注意：实际生产环境中的性能会因各种因素而有所不同，上述数据仅供参考。

## Web框架性能参考 (基于 Intel Xeon Platinum 5120)

测试环境说明：
- CPU: Intel Xeon Platinum 5120 (14核28线程，2.2GHz)
- 内存: 128GB
- 操作系统: Linux
- 网络: 10Gbps

### 单核性能基准

| 框架/平台                    | 单核QPS    | 总QPS     | 延迟      | 特点                          |
|----------------------------|------------|-----------|-----------|------------------------------|
| drogon (C++)              | 272,325    | 7,625,122 | ~0.15ms   | C++异步框架，性能极致           |
| actix (Rust)              | 266,438    | 7,460,265 | ~0.16ms   | Rust生态最快的Web框架          |
| ulib-plaintext (C++)      | 264,394    | 7,403,040 | ~0.16ms   | 专注于性能的C++库              |
| fasthttp (Go)             | 251,533    | 7,042,919 | ~0.17ms   | Go高性能HTTP库                |
| h2o (C)                   | 219,063    | 6,133,765 | ~0.19ms   | 高性能HTTP服务器               |

### 主流框架单核性能

| 框架                        | 单核QPS    | 总QPS     | 特点                          |
|----------------------------|------------|-----------|------------------------------|
| gin (Go)                   | 119,837    | 3,355,429 | Go生态系统最流行框架           |
| spring (Java)              | 101,952    | 2,854,646 | Java企业级框架                |
| express (Node.js)          | 37,251     | 1,043,029 | Node.js最流行的框架           |
| flask (Python/gunicorn)    | 13,018     | 364,495   | Python轻量级框架              |
| django (Python/gunicorn)   | 10,554     | 295,505   | Python全功能框架              |

### 性能分层（单核基准）

1. **超高性能层 (20万+ QPS/核)**
   - drogon: ~27万 QPS/核
   - actix: ~26.6万 QPS/核
   - ulib: ~26.4万 QPS/核
   - fasthttp: ~25万 QPS/核

2. **高性能层 (10万-20万 QPS/核)**
   - gin: ~12万 QPS/核
   - spring: ~10万 QPS/核

3. **中等性能层 (3万-10万 QPS/核)**
   - express: ~3.7万 QPS/核

4. **标准性能层 (1万-3万 QPS/核)**
   - flask: ~1.3万 QPS/核
   - django: ~1万 QPS/核

### 实际应用性能估算

在实际业务场景中，由于需要处理业务逻辑，性能通常会降至基准测试的10%-50%：

1. **简单业务逻辑 (50% 基准性能)**
   - C++/Rust框架: 10-13万 QPS/核
   - Go框架: 5-6万 QPS/核
   - Java框架: 4-5万 QPS/核
   - Node.js: 1.5-2万 QPS/核
   - Python框架: 5000-7000 QPS/核

2. **常规业务逻辑 (25% 基准性能)**
   - C++/Rust框架: 5-7万 QPS/核
   - Go框架: 2.5-3万 QPS/核
   - Java框架: 2-2.5万 QPS/核
   - Node.js: 8000-10000 QPS/核
   - Python框架: 2500-3500 QPS/核

3. **复杂业务逻辑 (10% 基准性能)**
   - C++/Rust框架: 2-3万 QPS/核
   - Go框架: 1-1.5万 QPS/核
   - Java框架: 8000-10000 QPS/核
   - Node.js: 3000-4000 QPS/核
   - Python框架: 1000-1500 QPS/核

### 性能优化建议

1. **架构层面**
   - 合理利用多核（CPU亲和性）
   - 使用异步/协程处理I/O
   - 采用合适的进程/线程模型

2. **应用层面**
   - 减少业务逻辑复杂度
   - 使用缓存减少计算
   - 优化数据库访问
   - 合理的内存管理

3. **系统层面**
   - TCP参数优化
   - 文件描述符限制调整
   - NUMA优化
   - 中断亲和性设置

### 选型参考

1. **性能敏感场景**
   - 网关/代理：drogon, actix, fasthttp
   - API服务：gin, spring reactive
   - 推荐单核性能 > 10万 QPS的框架

2. **普通业务场景**
   - Web应用：gin, spring, express
   - 推荐单核性能 > 3万 QPS的框架

3. **快速开发场景**
   - 内部服务：flask, django
   - 原型开发：express, flask
   - 单核性能 > 1万 QPS即可

注意：实际性能会受到网络、存储、业务逻辑等多个因素影响，以上数据仅供参考。建议在选型时进行实际业务场景的性能测试。

## 贡献

欢迎贡献新的实现方式或改进现有的实现。请创建一个新的分支，添加您的实现，并提交 pull request。

## 许可

[MIT License](LICENSE)