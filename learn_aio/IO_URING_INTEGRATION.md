# io_uring 集成总结

## 概述

本次更新为 AIO 基准测试工具添加了 io_uring 支持，使其能够同时支持传统的 libaio 和现代的 io_uring 两种异步IO引擎，方便进行性能对比测试。

## 主要变更

### 1. 架构重构

#### 新增文件
- `src/io_engine.h` - 通用IO引擎基类接口
- `src/uring_engine.h` - io_uring引擎头文件
- `src/uring_engine.cpp` - io_uring引擎实现
- `compare_engines.sh` - 引擎性能对比脚本

#### 修改文件
- `src/config.h` - 添加引擎类型枚举和配置
- `src/config.cpp` - 添加引擎类型命令行参数解析
- `src/aio_engine.h` - 继承通用接口
- `src/aio_engine.cpp` - 适配新的基类结构
- `src/benchmark.h` - 使用通用引擎接口
- `src/benchmark.cpp` - 支持动态创建不同类型引擎
- `CMakeLists.txt` - 添加liburing依赖和新源文件
- `README.md` - 更新文档说明

### 2. 新增功能

#### 引擎类型选择
```bash
# 使用libaio引擎（默认）
./aio_bench -f test.dat -e libaio

# 使用io_uring引擎
./aio_bench -f test.dat -e io_uring
```

#### 性能对比
- 支持相同参数下的两种引擎性能对比
- 提供对比脚本自动化测试
- 统一的性能指标输出格式

### 3. 技术实现

#### 接口设计
```cpp
class IOEngine {
public:
    virtual bool initialize() = 0;
    virtual bool submit_io(uint64_t offset, uint32_t size, bool is_read) = 0;
    virtual int wait_for_completion(int timeout_ms = -1) = 0;
    virtual void process_completions() = 0;
    virtual size_t get_pending_count() const = 0;
};
```

#### io_uring实现特点
- 使用liburing库简化开发
- 支持轮询和等待两种模式
- 高效的批量完成处理
- 与libaio引擎相同的内存管理策略

## 性能测试结果

### 测试环境
- 系统: Ubuntu Linux
- 测试文件: 500MB
- 参数: 随机读写, 队列深度32, 2线程, 10秒

### 测试结果对比

| 指标 | libaio | io_uring | 差异 |
|------|--------|----------|------|
| 平均 IOPS | 107,755 | 85,581 | -20.6% |
| 平均带宽 | 420.92 MB/s | 334.30 MB/s | -20.6% |
| 平均延迟 | 151.99 μs | 500.55 μs | +229% |
| P95延迟 | 612.00 μs | 1687.00 μs | +175% |
| P99延迟 | 1395.00 μs | 2638.00 μs | +89% |

#### 腾讯云测试环境数据对比

**测试环境**: 腾讯云CVM, 测试设备: /dev/vdb, 测试模式: rand_write, 测试时长: 30秒



应该是撞到burst了，所以libaio长时间跑的时候被限制了，但io_uring瞬时能跑到5W，这里是公平的对比。

#### 性能对比数据（相同IOPS水平）

| 指标 | libaio (30s) | io_uring (8s) | 差异 |
|------|-------------|---------------|------|
| **IO性能指标** | | | |
| 平均 IOPS | 50,058 | 50,239 | +0.4% |
| 平均带宽 | 195.54 MB/s | 196.25 MB/s | +0.4% |
| 平均延迟 | 618.28 μs | 612.92 μs | -0.9% |
| P95延迟 | 1217.00 μs | 1217.00 μs | 0.0% |
| P99延迟 | 1767.00 μs | 1748.00 μs | -1.1% |
| **CPU性能监控 - 每IO标准化** | | | |
| 每IO指令数 | 281.3 | 249.0 | -11.5% |
| 每IO CPU周期 | 239.3 | 235.7 | -1.5% |
| 每IO分支数 | 56.8 | 50.0 | -12.0% |
| 指令执行效率(IPC) | 1.176 | 1.057 | -10.1% |
| 分支预测失败率 | 15.5% | 18.3% | +18.1% |
| **真实CPU效率评估** | 基准 | 更高效 | **节省11.5%指令** |

按照这个换算, 单核拉满, 实际上是2G/235.7 = 848W IOPS, 则5W IOPS, libaio和uring实际CPU消耗仅占0.5%个核?

**原始测试数据**:

```
[root@VM-1-11-tencentos build]# ./aio_bench -f /dev/vdb -M -p rand_write
AIO 基准测试工具 v1.0

初始化完成，准备开始测试...
开始基准测试...
启用性能分析模式...
线程 0 开始工作...
线程 0 完成，总操作数: 1502734

=== 最终统计报告 ===
总运行时间: 30.02 秒
总操作数: 1502734
读操作数: 0
写操作数: 1502734
总字节数: 6155198464 (5870.05 MB)
读取字节: 0 (0.00 MB)
写入字节: 6155198464 (5870.05 MB)
错误数: 0

平均 IOPS: 50058.05
平均带宽: 195.54 MB/s
平均延迟: 618.28 μs
P95延迟: 1217.00 μs
P99延迟: 1767.00 μs
=================

|               ns/op |                op/s |    err% |          ins/op |          cyc/op |    IPC |         bra/op |   miss% |     total | AIO基准测试性能分析
|--------------------:|--------------------:|--------:|----------------:|----------------:|-------:|---------------:|--------:|----------:|:----------------------------
|   30,161,595,801.00 |                0.03 |    0.0% |  422,759,899.00 |  359,622,396.00 |  1.176 |  85,402,712.00 |   15.5% |     30.16 | `AIO测试完整执行`


[root@VM-1-11-tencentos build]# ./aio_bench -f /dev/vdb -M -p rand_write -e io_uring
AIO 基准测试工具 v1.0

初始化完成，准备开始测试...
开始基准测试...
启用性能分析模式...
线程 0 开始工作...
线程 0 完成，总操作数: 389696

=== 最终统计报告 ===
总运行时间: 30.03 秒
总操作数: 389696
读操作数: 0
写操作数: 389696
总字节数: 1596194816 (1522.25 MB)
读取字节: 0 (0.00 MB)
写入字节: 1596194816 (1522.25 MB)
错误数: 0

平均 IOPS: 12976.31
平均带宽: 50.69 MB/s
平均延迟: 2442.31 μs
P95延迟: 11843.00 μs
P99延迟: 12358.00 μs
=================

|               ns/op |                op/s |    err% |          ins/op |          cyc/op |    IPC |         bra/op |   miss% |     total | AIO基准测试性能分析
|--------------------:|--------------------:|--------:|----------------:|----------------:|-------:|---------------:|--------:|----------:|:----------------------------
|   30,068,426,125.00 |                0.03 |    0.0% |   99,747,395.00 |   93,343,212.00 |  1.069 |  19,954,596.00 |   17.8% |     30.07 | `AIO测试完整执行`


[root@VM-1-11-tencentos build]# ./aio_bench -f /dev/vdb -M -p rand_write -e io_uring -r 8
AIO 基准测试工具 v1.0

初始化完成，准备开始测试...
开始基准测试...
启用性能分析模式...
线程 0 开始工作...
线程 0 完成，总操作数: 402780

=== 最终统计报告 ===
总运行时间: 8.02 秒
总操作数: 402780
读操作数: 0
写操作数: 402780
总字节数: 1649786880 (1573.36 MB)
读取字节: 0 (0.00 MB)
写入字节: 1649786880 (1573.36 MB)
错误数: 0

平均 IOPS: 50239.47
平均带宽: 196.25 MB/s
平均延迟: 612.92 μs
P95延迟: 1217.00 μs
P99延迟: 1748.00 μs
=================

|               ns/op |                op/s |    err% |          ins/op |          cyc/op |    IPC |         bra/op |   miss% |     total | AIO基准测试性能分析
|--------------------:|--------------------:|--------:|----------------:|----------------:|-------:|---------------:|--------:|----------:|:----------------------------
|    8,054,761,835.00 |                0.12 |    0.0% |  100,301,419.00 |   94,935,996.00 |  1.057 |  20,149,777.00 |   18.3% |      8.05 | `AIO测试完整执行`

```


### 结果分析

在当前测试环境下，libaio表现优于io_uring，这可能由于：

1. **测试环境限制**: 虚拟化环境可能不能充分发挥io_uring优势
2. **工作负载特性**: 小文件随机IO可能不是io_uring的最佳场景
3. **实现优化**: io_uring实现可能还有优化空间
4. **内核版本**: 较新的内核版本对io_uring有更好的优化

## 使用指南

### 基本对比测试
```bash
# 创建测试文件
dd if=/dev/zero of=test.dat bs=1M count=100

# 测试libaio
./aio_bench -f test.dat -e libaio -p rand_rw -q 32 -t 2 -r 10

# 测试io_uring
./aio_bench -f test.dat -e io_uring -p rand_rw -q 32 -t 2 -r 10

# 自动对比
./compare_engines.sh
```

### 不同场景测试
```bash
# 高队列深度测试
./aio_bench -f test.dat -e io_uring -q 128 -t 4 -r 30

# 轮询模式测试
./aio_bench -f test.dat -e io_uring -P -q 32 -r 30

# 大块IO测试
./aio_bench -f test.dat -e io_uring -b 64k -q 16 -r 30
```

## 依赖要求

### 系统要求
- Linux 内核 5.1+ (io_uring支持)
- liburing 开发库

### 安装依赖
```bash
# Ubuntu/Debian
sudo apt-get install liburing-dev

# CentOS/RHEL
sudo dnf install liburing-devel
```

## 未来改进

### 性能优化
1. **固定缓冲区**: 使用io_uring的固定缓冲区特性
2. **SQ轮询**: 实现提交队列轮询模式
3. **链式操作**: 利用io_uring的操作链接功能
4. **批量优化**: 改进批量提交和完成处理

### 功能扩展
1. **更多IO操作**: 支持fsync、fallocate等操作
2. **网络IO**: 扩展支持网络IO测试
3. **高级特性**: 支持io_uring的高级特性如SQPOLL

### 测试完善
1. **更多场景**: 添加更多测试场景和工作负载
2. **自动化**: 完善自动化测试和性能回归检测
3. **文档**: 补充更详细的使用文档和最佳实践

## 总结

本次集成成功为AIO基准测试工具添加了io_uring支持，实现了：

✅ **架构重构**: 采用面向对象设计，支持多种引擎  
✅ **功能完整**: io_uring引擎功能与libaio对等  
✅ **易于使用**: 简单的命令行参数切换引擎  
✅ **性能对比**: 提供便捷的性能对比工具  
✅ **文档完善**: 更新了完整的使用文档  

这为深入研究和对比两种异步IO技术提供了强有力的工具支持。 