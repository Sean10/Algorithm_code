# 编译互斥锁示例
clang++ demo_mutex.cc -std=c++11 -stdlib=libc++

# 编译锁性能对比示例
clang++ lock_benchmark.cc -std=c++11 -stdlib=libc++ -o lock_benchmark

# 对比测试：
线程数：4
每个线程循环次数：100000
测量指标：
计数器最终值（验证正确性）
每次加锁操作的平均延迟（微秒）
运行程序后，你可以看到两种锁的性能对比。一般来说：
自旋锁在临界区很小且竞争不激烈时性能更好
互斥锁在临界区较大或竞争激烈时更适合，因为它会让出 CPU
你可以通过调整 NUM_THREADS 和 ITERATIONS 来测试不同场景下的性能表现。

## 运行结果

```
CPU核心数: 4

=== 测试场景 ===
线程数: 4
每线程迭代次数: 10000
持锁时间: 0 微秒

互斥锁结果 (持锁时间: 0微秒):
- 最终计数器值: 40000
- 平均每次加锁操作延迟: 0.20555 微秒
- 每秒操作次数: 4.86499e+06

自旋锁结果 (持锁时间: 0微秒):
- 最终计数器值: 40000
- 平均每次加锁操作延迟: 0.17449 微秒
- 每秒操作次数: 5.73099e+06


=== 测试场景 ===
线程数: 4
每线程迭代次数: 10000
持锁时间: 1 微秒

互斥锁结果 (持锁时间: 1微秒):
- 最终计数器值: 40000
- 平均每次加锁操作延迟: 7.42157 微秒
- 每秒操作次数: 134742

自旋锁结果 (持锁时间: 1微秒):
- 最终计数器值: 40000
- 平均每次加锁操作延迟: 4.63311 微秒
- 每秒操作次数: 215838


=== 测试场景 ===
线程数: 4
每线程迭代次数: 10000
持锁时间: 10 微秒

互斥锁结果 (持锁时间: 10微秒):
- 最终计数器值: 40000
- 平均每次加锁操作延迟: 46.3798 微秒
- 每秒操作次数: 21561.1

自旋锁结果 (持锁时间: 10微秒):
- 最终计数器值: 40000
- 平均每次加锁操作延迟: 40.7026 微秒
- 每秒操作次数: 24568.4


=== 测试场景 ===
线程数: 4
每线程迭代次数: 10000
持锁时间: 100 微秒

互斥锁结果 (持锁时间: 100微秒):
- 最终计数器值: 40000
- 平均每次加锁操作延迟: 358.141 微秒
- 每秒操作次数: 2792.2

自旋锁结果 (持锁时间: 100微秒):
- 最终计数器值: 40000
- 平均每次加锁操作延迟: 400.63 微秒
- 每秒操作次数: 2496.07
```