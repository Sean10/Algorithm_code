# 生产者-消费者 RPC 服务

这是一个基于gRPC的生产者-消费者模式实现，包含以下特性：

- 单线程生产者，使用线程安全队列存储生产的ID
- 多线程RPC服务器处理消费请求
- 基于协程的客户端，支持并发请求
- 实时性能监控（延迟和IOPS）

## 环境要求

- Python 3.7+
- gRPC
- Protocol Buffers

## 安装

1. 克隆仓库后，安装依赖：
```bash
pip install -r requirements.txt
```

2. 生成gRPC代码：
```bash
python -m grpc_tools.protoc -I. --python_out=. --grpc_python_out=. producer_consumer.proto
```

## 使用方法

1. 启动服务器：
```bash
python server.py
```

2. 在另一个终端启动客户端：
```bash
python multi_client.py
```

## 性能表现

### 实际性能指标
- 平均延迟: ~0.4ms
- 每进程IOPS: ~650
- 总IOPS: ~3250 (5个进程)
- 延迟抖动极小，系统稳定性好

### 基准测试结果
使用C语言实现的队列基准测试(`queue_benchmark.c`)显示了系统的理论性能上限：

```
测试结果 (微秒):
线程数: 50
每线程测试次数: 10000
平均延迟: 15.38
最小延迟: 0.00
最大延迟: 16756.00
理论每秒处理能力: 3251385.42
```

### 性能分析

1. 服务端设计要点：
- 单线程生产保证ID严格递增
- 使用线程安全队列（Queue）存储ID
- 合理的线程池大小（50个工作线程）
- 适当的队列大小（10000）提供缓冲

2. 客户端优化：
- 多进程+协程的并发模型
- 每个进程维护合适的并发数（20）
- 使用信号量控制并发
- 请求发送更平滑，避免突发

3. 参数选择依据：
- 队列操作基准延迟约15微秒
- 考虑RPC框架开销，单个请求总延迟约0.4ms
- 线程池大小50能较好平衡延迟和吞吐量
- 5个客户端进程提供足够并发度

4. 性能优化空间：
- 使用无锁队列
- 实现批量操作接口
- 使用内存预分配
- 采用多队列分片策略

## 实现细节

- 服务器使用 Queue 实现线程安全的ID队列
- 生产者以固定速率生成递增的ID
- 客户端使用协程实现并发请求
- 使用滑动窗口计算性能指标

## 注意事项

- 服务器默认监听 50051 端口
- 客户端默认5个进程，每进程20并发
- 可以通过修改代码中的相关参数调整性能 